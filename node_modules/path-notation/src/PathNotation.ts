const KEYS_KEY:unique symbol = Symbol();

/**
  @description Dot-notation based path string which yields key literals, allows for the inclusion of keys with "." characters, and provides node meta data and other useful utilities.
  @extends String
*/
export default class PathNotation extends String {

  private readonly [KEYS_KEY]:string[];

  /**
    @description Creates a PathNotation instance.
    @arg {string | number | String | Iterable<string | number | String>} pathNotationOrKey - 
      Key in path notation e.g. "foo.bar['baz.qux']" or a single path key.
    @arg {...(string | number | String)} [keys] - Optional child path keys.
  */
  constructor(
    pathNotationOrKey:string | number | String | Iterable<string | number | String>, 
    ...keys:(string | number | String)[]
  ){

    const keysToSet:string[] = [];

    switch(typeof pathNotationOrKey){

      case 'string':

        keysToSet.push(...PathNotation.pathNotationToKeys(<string>pathNotationOrKey));
        break;

      case 'number':

        keysToSet.push(...PathNotation.pathNotationToKeys(pathNotationOrKey.toString()));
        break;

      default:

        if(pathNotationOrKey instanceof String && !(pathNotationOrKey instanceof PathNotation)){

          keysToSet.push(pathNotationOrKey.toString());
          break;

        }

        for(const keyLiteral of <Iterable<string | number>>pathNotationOrKey){

          keysToSet.push(keyLiteral.toString());

        }

    }

    for(const keyLiteral of keys){

      keysToSet.push(keyLiteral.toString());

    }

    super(PathNotation.keysToPathNotation(keysToSet));

    this[KEYS_KEY] = keysToSet;

  }

  //Accessors
  /**
    @description Number of key literals in path.
    @type {number}
  */
  get numKeys(){

    return this[KEYS_KEY].length;

  }

  /**
    @description Zero based node depth of terminal key in path.
    @type {number}
  */
  get depth(){

    return this[KEYS_KEY].length - 1;

  }

  /**
    @description First key literal in path.
    @type {string}
  */
  get rootKey(){

    return this[KEYS_KEY][0];

  }

  /**
    @description Last key literal in path.
    @type {string}
  */
  get terminalKey(){

    return this[KEYS_KEY][this.depth];

  }

  get [Symbol.toStringTag]() {
  
    return this.constructor.name;
  
  }

  //Methods
  /**
    @description Yields key literals from path.
    @generator
    @yields {string} The next key litreral in path.
  */
  *keys(){

    let i = 0;

    for(let key of this[KEYS_KEY]){

      i++;

      let remainingPath = yield key;

      while(remainingPath === true){

        remainingPath = yield PathNotation.keysToPathNotation(this[KEYS_KEY].slice(i));

      }

    }

  }
  
  /**
    @description Returns parent path.
    @arg {number} keyDepth - 0 based index of parent path.  Cannot be greater than [PathNotation.depth]{@link Path#depth}.
  */
  parentPath(keyDepth:number):PathNotation{

    const DEPTH = this.depth;

    if(keyDepth >= DEPTH){

      throw new Error(`A parent 'PathNotation.depth' must be less than it's children 'PathNotation.depth(s)'.`);

    }

    return new PathNotation(this[KEYS_KEY].slice(0, keyDepth + 1));

  }

  *[Symbol.iterator]():IterableIterator<string>{

    yield* this[KEYS_KEY];

  }

  /**
    @description Yileds key literals dot-notated path.
    @generator
    @yields {string} The next key litreral in path.
  */
  static *pathNotationToKeys(path:string):IterableIterator<string>{

    const escapedKeys:Map<string, string> = new Map();

    //["@key"]
    path = path.replace(/\["(.+)"\]/g, (m, key)=>{

      let placeHolder:string;
      
      do {

        placeHolder = `{%${Math.floor(Math.random()*10**4)}%}`;

      } while(escapedKeys.has(placeHolder));

      escapedKeys.set(placeHolder, key);

      return `.${placeHolder}.`;

    });

    //['@key']
    path = path.replace(/\['(.+)'\]/g, (m, key)=>{

      let placeHolder:string;
      
      do {

        placeHolder = `{%${Math.floor(Math.random()*10**4)}%}`;

      } while(escapedKeys.has(placeHolder));

      escapedKeys.set(placeHolder, key);

      return `.${placeHolder}.`;

    });

    //Remove trailing '.'
    if(path.slice(-1) === '.'){

      path = path.slice(0, -1);

    }

    for(let key of path.split('.')){

      yield escapedKeys.has(key) ? escapedKeys.get(key) : key;

    }

  }

  /**
    @description Returns dot-notated path.
    @returns {string} Dot-notated path.
  */
  static keysToPathNotation(keys:Iterable<string>):string{

    let pathNotation = '';

    let lastWasBracketNotation = false;

    for(let key of keys){

      if(key.indexOf('.') > -1){

        pathNotation += `["${key}"]`;

        lastWasBracketNotation = true;

      } else if(lastWasBracketNotation){

        pathNotation += `${key}`;

        lastWasBracketNotation = false;

      } else {

        pathNotation += `.${key}`;

      }

    }

    //Remove leading "."
    return pathNotation.slice(1);

  }
  
}